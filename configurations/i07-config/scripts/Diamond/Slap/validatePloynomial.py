
'''
ce=[c0, c1, c2, ...]
y=c0 + c1*x + c2*x^2 + c3*x^3 + ...
'''
def simple_polynomial(x, ce):
	y=0.0;
	for n in range( len(ce) ):
		y += ce[n] * pow(x, n)

	return y;

def phaseToDelay(phase):
#		if phase < 2000:
#			print "Warning: for FPS less than 2000, the calculated delay time is not accurate!";
	
	#original calibration data 	
#		ce=[-314.54743880779006, 0.2178067078267, -4.42112289919133E-5, 6.23201260834173E-9, -4.56389485255816E-13, 1.87822227452686E-17, -4.38244545149381E-22, 5.74992260755205E-27, -3.95507764236028E-32, 1.10917614752542E-37];
	#new calibration data provided on 01/05/2012
	ce=[-0.0058976070255, 1.31253880142145E-4, -2.26326432895618E-8, 3.53663784002266E-12, -2.63010486113614E-16, 1.04042843159956E-20, -2.16666613588553E-25, 2.26190976227321E-30, -9.58629545249244E-36, 2.90678349766489E-42];
	delay=simple_polynomial(phase, ce)
	return delay;
				
			
def delayToPhase(delay):
#	ce=[2091.8453502214797, 13.77230216629964, -6.26019393495315E-4, -1.43939298680241E-6, 6.07660339122771E-10, -1.20844686370414E-13, 1.37221846732618E-17,-9.06457446332099E-22, 3.23991999300214E-26, -4.83871779102917E-31];
	ce=[-88.36914666723533, 12855.32380237554, 824.10592216745135, -1946.0535305088042, 664.20982780807435, -115.31870988361487, 11.61543948306145, -0.68333494362544, 0.02173576685147, -2.87621826209067E-4];
	phase = simple_polynomial(delay, ce)
	return phase;


for p0 in (0, 1000, 2000, 3000, 4000, 5000,10000,20000,30000,40000,50000,60000):
    d0=phaseToDelay(p0)
    print "phase=%g ---> delay=%g, " %(p0,d0), 

    p1=delayToPhase(d0)
    print "delay=%g ---> phase=%g" %(d0,p1)
    print
