slices_type = 1 # 0 - single slice, 1 - several slices
slices_first =  0
slices_last = 155
slices_step  =  1

input_file = e.tif
# input_file = C:\Documents and Settings\Sofya\My Documents\Visual Studio 2005\Projects\FBP-test\Data\gr_core\grcore_slice_0300.tif
input_file_path = .
input_file_prefix = c006_s 
input_file_suffix = .tiff
input_file_number_of_digits = 5

input_type = 0		# 0 - intensity; 1 - optical path
input_restrictions = 0 # 0 - no restrictions, 1 - positive values, 2 - zero corresponds to the 50% grey value, 3 - minimal/maximal values are given
input_minimal_value = 0.0
input_maximal_value = 2.0

output_file = slice.tif
#output_file = K:\Slices\slice_proc_02012_40_res2.tif
#output_file_path = /tmp/Diamond/fbp/data
output_file_path = /dls/i12/data/2010/ee2213-1/processing/907/images/recon_job2303134
output_file_prefix = zzzzbig_c006_sol
output_file_suffix = .tif
output_file_number_of_digits = 5

output_image_width = 4008
output_image_height = 4008
output_restrictions = 3 # 0 - no restrictions, 1 - positive values, 2 - zero corresponds to the 50% grey value, 3 - minimal/maximal values are given
output_minimal_value = -1.0
output_maximal_value = 1.0

output_area_type = 0 # 0 - full circle, 1 - circular sector, 2 - convex polygon
output_polygon_path = /tmp/Diamond/fbp/data/poly.txt
output_keep_aspect_ratio = 0 # 0 - yes, 1 - no
output_width_in_priority = 0 # 0 - yes, 1 - no

output_level = 0		# 0 - solution, 1 - path length (preprocessed), 2 - filtered data, 3 - solution in polar coordinates, 4 - flat feild correction (preprocessed).
output_type = 0 # 0 - FBP, 1 - Hilbert

scale_sinogram_factor = 3
scale_sinogram_chunk = 70

flat_field_file = flat.tif
flat_field_row = 0
flat_field_first_row = 0
flat_field_last_row = 0
flat_field_user_value = 65535
flat_field_type = 5
#(0) value by a user, (1) value = mean of the image, (2) value = mean of the row, (3) value = mean of the strip, (4) row = average of the image, (5) the row, (6) row = average of the strip

dark_noise_file = dark.tif
dark_noise_row = 0
dark_noise_first_row = 0
dark_noise_last_row = 0
dark_noise_user_value = 0.0
dark_noise_type = 5
#(0) value by a user, (1) value = mean of the image, (2) value = mean of the row, (3) value = mean of the strip, (4) row = average of the image, (5) the row, (6) row = average of the strip

intensity_normalization_type = 1 # 0 - constant, 1 - optical path along a row is a constant, 2 - exponential decay, 3 - columns where there is always a flat field
intensity_normalization_first_column = 0
intensity_normalization_last_column = 300
intensity_normalization_when = 1 # 0 - before ring artefacts removal, 1 - after
intensity_normalization_decay_type = 0 # 0 - ratio of intensities (last/first), 1 - flat fields before and after the experiment
intensity_normalization_decay_file_first = C:\Documents and Settings\Sofya\My Documents\Visual Studio 2005\Projects\FBP-test\Data\gr_core\flat1_00001.TIF
intensity_normalization_decay_file_last = C:\Documents and Settings\Sofya\My Documents\Visual Studio 2005\Projects\FBP-test\Data\gr_core\flat2_00001.TIF
intensity_normalization_decay_ratio = 0.5

high_peaks_column_type = 1 # 0 - no processing, 1 - processing (the processing is before the ring artefact removal)
high_peaks_column_lipschitz = 0.01 # value of a Lipschitz constant along a column
high_peaks_column_num = 1 # number of neighbouring pixels (above the given pixel; the same number is for pixels below) to be used
high_peaks_general_type = 0 # 0 - no processing, 1 - processing (the processing is after the ring artefact removal)
high_peaks_general_vert_lipschitz = 0.01 # value of a Lipschitz constant along a column
high_peaks_general_hor_lipschitz = 0.01 # value of a Lipschitz constant along a row
high_peaks_general_vert_num = 1 # number of neighbouring pixels (vert)
high_peaks_general_hor_num = 1 # number of neighbouring pixels (horiz)

ring_type = 3 # 0 - no ring artefacts removal, 1 - subtracting average value of a column, 2 - regularization 3 regularization
ring_regul_parameter = 0.002
ring_regul_weight_rotation = 0.0
ring_regul_rotation_step = 0.5 # (0, 1]
ring_regul_rotation_extension_type = 0 # 0 - no extension, 1 - extension
ring_regul_rotation_extension_num = 40 # number of pixels used for extension
ring_regul_approx_level = 1
ring_regul_max_value = 1.0
ring_regul_num_deriv = 0
ring_regul_weight_deriv_0 = 1.0
ring_regul_weight_deriv_1 = 1.0
ring_regul_weight_deriv_2 = 1.0
ring_regul_scale_factor = 1.0


hilbert_approx_level = 2 # number of pixels from the left and the right of a given pixel used to find first derivative

filtering_bandwidth = 3.0
filtering_method = RL
filtering_convolution_method = Auto
filtering_number_of_threads = 8
filtering_precision = 0 # 0 - single, 1 - double
filtering_extension_type = 1 # 0 - no extension (the optical path outside the image equals zero), 1 - extension based on pixels near image's edges
filtering_extension_num = 40 # number of pixels for the extension
filtering_extesion_length_type = 0 # 0 - percentage, 1 - pixels
filtering_extesion_length_perc = 100.0
filtering_extesion_length_pixel = 600

image_centre = 2112.5 

backprojection_radius1_type = 0 # 0 - percentage, 1 - pixels
backprojection_radius1_value = 0.0
backprojection_radius2_type = 0 # 0 - percentage, 1 - pixels
backprojection_radius2_value = 100.0 
backprojection_angle1_value = 0.0
backprojection_angle2_value = 360.0
backprojection_dR_type = 1 # 0 - percentage, 1 - pixels
backprojection_dR_value = 0.2
backprojection_angular_period = 1
backprojection_points_per_angular_period = 1
backprojection_number_of_threads = 8
backprojection_interpolation_type = 0 # 0 - no, 1 - yes

polar_to_cartesian_angular_factor = 2.0
polar_to_cartesian_radial_factor = 1.0
polar_to_cartesian_interpolation = 1

application_precision = 0 # 0 - single, 1 - double
angle_type = 180
maximal_radius_type = 1 # 0 - the minimal distance between image center and end-points, 1 - the maximal one 

__end__

