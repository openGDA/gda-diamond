mu    --> DOF
delta --> DOF
gam   --> DOF

exec("kth=DOFAdapterWithStationaryRelativeLimits(kth.getOE(), kth.getDofname())")
exec("delta=DOFAdapterWithStationaryRelativeLimits(delta.getOE(), delta.getDofname())")
exec("gam=DOFAdapterWithStationaryRelativeLimits(gam.getOE(), gam.getDofname())")
exec("mu=DOFAdapterWithStationaryRelativeLimits(mu.getOE(), mu.getDofname())")

# Rename delta to deltaNoOffset
delta_no_offset=delta
delta_no_offset.setName('delta_no_offset')
delta_no_offset.setInputNames(['delta_no_offset'])

# Create a new delta with offset
exec("delta=OffsetAxisClass('delta', delta_no_offset, delta_axis_offset, help='delta device with offset given by delta_axis_offset. Use pos delta_axis_offset to change offset')")



DiffractTopClass:
********
import beamline_objects as BLobjects

# And as a fudge: Set the internal pointers to motors in BLobjects
# (The old way would (for now) by pass the new scannable limits)
BLobjects.my_kphi  --> kphi
BLobjects.my_kap   --> kap
BLobjects.my_kth   --> kth
BLobjects.my_mu    --> mu
BLobjects.my_delta --> delta
BLobjects.my_gam   --> gam

san = StoredAngles.StoredAngles()
	[Hunch: modify to read only!]
object san:
	ChangeAngle(key={Kphi,Kap,Kth,Kmu}, angle): moves one axis via BLobjects
	getAngles():
          d.Theta = euAngles.Theta
          d.Phi = euAngles.Phi
          d.Chi = euAngles.Chi

          d.Mu = BLobjects.getKmu().getPosition()
          d.Eta = euAngles.Theta
          d.Kmu = BLobjects.getKmu().getPosition()
          d.Kphi = BLobjects.getKphi().getPosition()
          d.Kap = BLobjects.getKap().getPosition()
          d.Kth = BLobjects.getKth().getPosition()
          d.Delta = BLobjects.getDelta().getPosition()
          d.Gam = BLobjects.getGam().getPosition()
          d.Gamma = BLobjects.getGam().getPosition()d.

Azimuth.Angles(san)
	[Gets angles only]
********

import EulerianKconversionModes
EKCM = EulerianKconversionModes.EulerianKconversionModes()
	[Red herring]


import beamline_objects as BLobjects
module BLobjects:
	isBusy():kphi, kap, kth, mu only
	getScattreringPlane(): returns gam or delta
	getTth(): (ditto)
	ketKphi()...getGam()



# Use the next three lines for normal Eulerian pseudo device
import EulerianPseudoDevice
reload(EulerianPseudoDevice)
euler = EulerianPseudoDevice.EulerianPseudoDevice("euler",san,mu,delta,gam)

object euler(san,mu,delta,gamma):
	[
	[inputs = phi, chi, eta  extra: mu, delta, gamma]
	asynchronousMoveTo(phi, chi, eta, !mu!):
		eulerianKConversionModes.getKPossibleAngles([eta,chi,phi])->a.KTheta,a.K,a.KPhi
		checks safe to moveL Kth,Kap and Kphi
		moves:mu, Kth, Kap, Kphi (stopping all if problem)
	isBusy():
		returns BLobjects.isBusy [kphi, kap, kth, mu only]
	getPosition():
		returns stored angles:phi, chi, eta, mu, delta, gamma

import EulerianAxisPseudoDevice
reload(EulerianAxisPseudoDevice)
phi = EulerianAxisPseudoDevice.EulerianAxisPseudoDevice("phi",euler,san)
chi = EulerianAxisPseudoDevice.EulerianAxisPseudoDevice("chi",euler,san)
eta = EulerianAxisPseudoDevice.EulerianAxisPseudoDevice("eta",euler,san)

objects phi, chi, eta:
	__init__(euler,san)
	getPosition():
		returns value from euler [good!]
	asynchronousMoveTo(pos)
		1) checks own limit
		2) waits for euler to stop being busy!
		3) creates a new (phi,chi,eta) passes into ekxm, then moves via san
		4) for a chi scan it remembers the positions at start and fixes them 
	def isBusy(self):
		return self.euler.isBusy()	

hkl = hklPseudoDevice.hklPseudoDevice("hkl",euler,delta,rs,CA,EDi,delta,gam,az)
	[delta,gam,euler]
import hklAxisPseudoDevice
reload(hklAxisPseudoDevice)
h = hklAxisPseudoDevice.hklAxisPseudoDevice("h",hkl)
k = hklAxisPseudoDevice.hklAxisPseudoDevice("k",hkl)
l = hklAxisPseudoDevice.hklAxisPseudoDevice("l",hkl)

object hkl:
	def isBusy(self):
      		if self.delta.isBusy() ==1 or self.gam() == 1 or self.euler.isBusy() == 1:
	def getPosition():
		gets state using StoredAngles andBLi
		return rs.calcHKL(All Nones)
	def asynchronousMoveTo([h,k,l]):
		to float
		angles = self.cal.getAngles
		euler_positions = [angles.Phi,angles.Chi,angles.Eta,angles.Mu,angles.Delta,angles.Gamma]
		check delta, #gamma#
		move euler
		move delta
		move gamma
		
		


import fourCirclePseudoDevice
reload(fourCirclePseudoDevice)
fourcircle = fourCirclePseudoDevice.fourCirclePseudoDevice("fourcircle",euler)

tth = BLobjects.getTth()                       #[Will be either delta or gamma]

psi = PsiPseudoDevice.PsiPseudoDevice("psi",euler,az,CA,hkl)





	