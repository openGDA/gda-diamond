/*-
 * Copyright Â© 2017 Diamond Light Source Ltd.
 *
 * This file is part of GDA.
 *
 * GDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 as published by the Free
 * Software Foundation.
 *
 * GDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GDA. If not, see <http://www.gnu.org/licenses/>.
 */

package gda.device.detector;

import java.util.HashMap;

import org.eclipse.dawnsci.analysis.api.io.IDataHolder;
import org.eclipse.january.dataset.Dataset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import gda.device.Detector;
import gda.device.DeviceException;
import gda.device.detector.xstrip.XhDetector;
import gda.scan.ede.TimeResolvedExperiment;
import uk.ac.diamond.scisoft.analysis.io.LoaderFactory;
import uk.ac.gda.exafs.ui.data.TimingGroup;

/**
 * This is a dummy implementation of an EdeDetector, similar to the {@link XhDetector} detector running with dummy da server.
 * The {@link#readoutFrames} method of this detector returns either
 * <li>Dummy values useful for debugging based on number of frames and MCA channels, generated by {@link#createDummyData}
 * <li>Values from a dataset loaded from a file using {@link#loadDetectorDataFromNexusFile}
 * <li>Values from a dataset specified by {@link#setDetectorData} </li>
 * This detector can be used in a {@link TimeResolvedExperiment} to replace real data with dummy values by using
 * {@link TimeResolvedExperiment#setDetectorForScanPart(gda.scan.ede.position.EdePositionType, gda.scan.ede.EdeScanType, EdeDetector)}
 *
 * @author Iain Hall
 */
public class EdeDummyDetector extends EdeDetectorBase {

	private static final long serialVersionUID = 530098100066901244L;

	private static final Logger logger = LoggerFactory.getLogger(EdeDummyDetector.class);

	private int numScansInFrame;
	private int maxPixel;

	private String mainDetectorName;
	private String dummyDetectorName;

	private Dataset detectorData;

	public EdeDummyDetector() {
		detectorData = null;
		maxPixel = 2048;
		setUpperChannel(maxPixel);
	}

	/**
	 * Set detector name : first call to this sets 'dummy detector' name. See {@link #atScanStart()}, {@link #atScanEnd()}.
	 */
	@Override
	public void setName(String name) {
		if (dummyDetectorName==null) {
			dummyDetectorName = name;
		}
		super.setName(name);
	}

	/**
	 * Set detector name to match that of real detector. This is done so data produced by 'dummy detector' is added to same Nexus group as data from 'real' detector.
	 */
	@Override
	public void atScanStart() {
		setName(mainDetectorName);
	}

	/**
	 * Reset name back to original 'dummy detector' name.
	 */
	@Override
	public void atScanEnd() {
		setName(dummyDetectorName);
	}

	@Override
	public void stop() {
		atScanEnd();
	}

	public String getDummyDetectorName() {
		return dummyDetectorName;
	}

	public void setDummyDetectorName(String dummyDetectorName) {
		this.dummyDetectorName = dummyDetectorName;
	}

	public String getMainDetectorName() {
		return mainDetectorName;
	}

	public void setMainDetectorName(String mainDetectorName) {
		this.mainDetectorName = mainDetectorName;
	}

	public void setMaxPixel(int maxPixel) {
		this.maxPixel = maxPixel;
		setUpperChannel(maxPixel);
	}

	@Override
	public int getMaxPixel() {
		return maxPixel;
	}

	/**
	 * Set dummy detector data directly from Dataset
	 * @param data
	 */
	public void setDetectorData(Dataset data) {
		this.detectorData = data;
	}

	/**
	 * Set dummy detector data by loading a Dataset from a Nexus file
	 * @param nexusFile
	 */
	public void loadDetectorDataFromNexusFile(String nexusFile) {
		// frelon raw count data, using 3rd row of values (counts for I0 measurement)
		loadDetectorDataFromNexusFile(nexusFile, "/entry1/frelon/data", 2);
	}

	public void loadDetectorDataFromNexusFile(String nexusFile, String pathToDataSet) {
		loadDetectorDataFromNexusFile(nexusFile, pathToDataSet, -1);
	}

	/**
	 * Read one or multiple rows (frames) of data from specified dataset in Nexus file and use it to set the dummy detector data
	 * @param nexusFile Full path to Nexus file
	 * @param pathToDataSet Path to Nexus dataset
	 * @param rowToUse  >=0 to select single row, -1 to use all
	 */
	public void loadDetectorDataFromNexusFile(String nexusFile, String pathToDataSet, int rowToUse) {
		try {
			logger.info("Setting dummy data from file {} : dataset = {}, row = {}", nexusFile, pathToDataSet, rowToUse);
			IDataHolder dataHolder = LoaderFactory.getData(nexusFile);
			Dataset dataFromFile = (Dataset) dataHolder.getLazyDataset(pathToDataSet).getSlice();
			int[] shape = dataFromFile.getShape();

			if (shape.length > 2 || shape.length==0) {
				logger.warn("Data in Nexus file is {}-dimensional - 1 or 2-dimensions required. Not setting dummy detector data.");
			}
			if (shape.length==2 && rowToUse>-1 && rowToUse<shape[0]) {
				detectorData = dataFromFile.getSlice(new int[]{rowToUse, 0}, new int[]{rowToUse+1, shape[1]}, null).squeeze();
			} else {
				detectorData = dataFromFile;
			}
		} catch (Exception e) {
				logger.error("Problem setting detector data from Nexus file", e);
		}
	}

	/**
	 * Readout frames of detector data, filling in the values from {@link #detectorData} (if present) or using {@link #createDummyData(int, int)}.
	 * <p> If detectorData has fewer columns than required number of channels, zeros will be used to pad columns.
	 * <p> If number of frames required > number of rows, row values will be cycled repeatedly as necessary.
	 */
	@Override
	public int[] readoutFrames(int startFrame, int finalFrame) throws DeviceException {
		logger.debug("readoutFrames");

		int[] datashape = new int[]{};

		if (detectorData!=null && detectorData.getShape()!=null) {
			datashape = detectorData.getShape();
		}

		if (datashape.length==0 || datashape.length>2) {
			logger.warn("Dimensions of dataset {} do not match requirements (must be 1 or 2-dimensional). Generating dummy data.", datashape.length);
			return createDummyData(startFrame, finalFrame);
		}

		int numRows = datashape.length == 1 ? 1 : datashape[0];
		int numColumns = datashape.length == 1 ? datashape[0] : datashape[1];

		int numFrames = finalFrame - startFrame + 1;
		if (numRows < numFrames) {
			logger.warn("Number of rows in dataset ({}) is less than number of frames to read ({}). Rows will be repeated to fill required frames.", numRows, numFrames);
		}
		if (numColumns < maxPixel) {
			logger.warn("Number of columns in dataset ({}) does not match number of MCA channels ({}). Zeros will be used for the missing channel values.", numColumns, maxPixel);
		}

		// Copy from dataset into int array, pad with zeros, cycle the rows if necessary.
		int []intData = new int[numFrames*maxPixel];

		int n=0;
		for(int i=0; i<numFrames; i++) {
			for(int j=0; j<maxPixel; j++) {
				int val = 0;
				if (j < numColumns) {
					if (datashape.length == 1) {
						val = detectorData.getInt(j);
					} else if (datashape.length == 2) {
						val = detectorData.getInt(i % numRows, j);
					}
				}
				intData[n++] = val;
			}
		}
		return intData;
	}

	/**
	 * Generate specified number of frames of dummy data. Each frame has {@link #getMaxPixel()} values, with the counts conveniently incremented to assist debugging and testing.
	 * @param startFrame
	 * @param finalFrame
	 * @return
	 */
	private int[] createDummyData(int startFrame, int finalFrame) {
		int numFrames = finalFrame - startFrame + 1;
		int[] intData = new int[numFrames * maxPixel];
		int n = 0;
		for (int i = 0; i < numFrames; i++) {
			for (int j = 0; j < maxPixel; j++) {
				intData[n++] = j + i * 100;
			}
		}
		return intData;
	}

	// EdeDetectorBase overrides - seem to be mostly not called for dummy detector when used in TimeResolved/Cyclic or SingleSpectrum scans

	@Override
	public int getNumberScansInFrame(double frameTime, double scanTime, int numberOfFrames) throws DeviceException {
		return numberOfFrames;
	}

	@Override
	public DetectorStatus fetchStatus() throws DeviceException {
		logger.debug("fetchStatus");
		DetectorStatus status = new DetectorStatus();
		status.setDetectorStatus(Detector.IDLE);
		return status;
	}

	@Override
	public int getNumberOfSpectra() throws DeviceException {
		logger.debug("getNumberOfSpectra");
		return 0;
	}

	@Override
	public HashMap<String, Double> getTemperatures() throws DeviceException {
		return null;
	}

	@Override
	public void fetchDetectorSettings() {
	}

	@Override
	public int getNumberScansInFrame() {
		return numScansInFrame;
	}

	@Override
	public void setNumberScansInFrame(int numScansInFrame) {
		this.numScansInFrame = numScansInFrame;
	}

	@Override
	public void configureDetectorForTimingGroup(TimingGroup group) throws DeviceException {
	}

	@Override
	public void configureDetectorForROI(int verticalBinning, int ccdLineBegin) throws DeviceException {
	}

	@Override
	public void collectData() throws DeviceException {
		logger.debug("collectData");
	}

	@Override
	public boolean createsOwnFiles() throws DeviceException {
		return false;
	}

	@Override
	protected void configureDetectorForCollection() throws DeviceException {
		logger.debug("configureDetectorForCollection");
	}

	@Override
	public void setSynchroniseToBeamOrbit(boolean synchroniseToBeamOrbit) {
	}

	@Override
	public boolean getSynchroniseToBeamOrbit() {
		return false;
	}

	@Override
	public void setSynchroniseBeamOrbitDelay(int synchroniseBeamOrbitDelay) throws DeviceException {
	}

	@Override
	public int getSynchroniseBeamOrbitDelay() {
		return 0;
	}

	@Override
	public void setOrbitWaitMethod(String methodString) {
	}

	@Override
	public String getOrbitWaitMethod() {
		return null;
	}

	@Override
	public int getLastImageAvailable() throws DeviceException {
		return 0;
	}
}
