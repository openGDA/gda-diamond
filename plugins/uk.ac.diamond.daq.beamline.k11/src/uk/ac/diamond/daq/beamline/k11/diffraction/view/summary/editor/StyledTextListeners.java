/*-
 * Copyright Â© 2021 Diamond Light Source Ltd.
 *
 * This file is part of GDA.
 *
 * GDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 as published by the Free
 * Software Foundation.
 *
 * GDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GDA. If not, see <http://www.gnu.org/licenses/>.
 */

package uk.ac.diamond.daq.beamline.k11.diffraction.view.summary.editor;

import java.util.Optional;

import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CaretListener;
import org.eclipse.swt.custom.StyledText;
import org.eclipse.swt.custom.VerifyKeyListener;
import org.eclipse.swt.events.VerifyEvent;
import org.eclipse.swt.events.VerifyListener;

import uk.ac.diamond.daq.beamline.k11.diffraction.view.summary.editor.handler.SummaryHandler;
import uk.ac.diamond.daq.mapping.api.document.AcquisitionTemplateType;
import uk.ac.gda.client.UIHelper;
import uk.ac.gda.client.exception.GDAClientException;
import uk.ac.gda.core.tool.spring.SpringApplicationContextFacade;
import uk.ac.gda.ui.tool.WidgetUtilities;
import uk.ac.gda.ui.tool.document.ScanningAcquisitionTemporaryHelper;

/**
 * Contains the logic related to the {@link StyledText} listeners
 *
 * @author Maurizio Nagni
 */
public class StyledTextListeners {

	private final AcquisitionSummary segmentUtils;

	public static final void addStyledTextListeners(AcquisitionSummary segmentUtils) {
		var instance = new StyledTextListeners(segmentUtils);
		instance.addListeners();
	}

	private StyledTextListeners(AcquisitionSummary segmentUtils) {
		this.segmentUtils = segmentUtils;
	}

	private void addListeners() {
		addCaretListener();
		addVerifyListener();
		addVerifyKeyListener();
	}

	private StyledText getSummaryText() {
		return segmentUtils.getSummaryText();
	}

	private void addCaretListener() {
		WidgetUtilities.addWidgetDisposableListener(getCaretListener(),
				getSummaryText()::addCaretListener,
				getSummaryText()::removeCaretListener,
				getSummaryText()::addDisposeListener,
				getSummaryText()::setData);
	}

	private void addVerifyListener() {
		WidgetUtilities.addWidgetDisposableListener(getVerifyListener(),
				getSummaryText()::addVerifyListener,
				getSummaryText()::removeVerifyListener,
				getSummaryText()::addDisposeListener,
				getSummaryText()::setData);
	}

	private void addVerifyKeyListener() {
		WidgetUtilities.addWidgetDisposableListener(getVerifyKeyListener(),
				getSummaryText()::addVerifyKeyListener,
				getSummaryText()::removeVerifyKeyListener,
				getSummaryText()::addDisposeListener,
				getSummaryText()::setData);
	}

	/**
	 * Listen at mouse click on the text.
	 *
	 * <p>
	 * This is the first action that a user does before edit a field.
	 * </p>
	 *
	 * @param summaryText
	 * @return
	 */
	private CaretListener getCaretListener() {
		return event -> {
			// Is the caret on an available segment?
			segmentUtils.segmentAtTextPosition(event.caretOffset)
				.ifPresentOrElse(s -> {
					if (!s.getGroup().isEditable())
						return;
					segmentUtils.drawBox(s);
					getSummaryText().setEditable(true);
				}, () -> {
					getSummaryText().setEditable(false);
					segmentUtils.removeBox();
				});
				segmentUtils.applyStyleRanges(getSummaryText());
			};
	}

	/**
	 * Listens at text update.
	 *
	 * <p>
	 * This is the third action that a user does while the field is editable. There are three possible
	 * </p>
	 *
	 * @param summaryText
	 * @return
	 */
	private VerifyListener getVerifyListener() {
		return event -> {
			Optional<Segment<?>> segment = segmentUtils.segmentAtTextPosition(event.start);

			segment.ifPresent(s -> {
				String newValue = event.text;
				// Handles Backspace and Delete
				if (event.text.length() == 0) {
					newValue = composeFinalString(event, s);
				}

				// Handles a single alphanumeric character
				if (event.text.length() == 1 && !event.text.equals("\n")) {
					if (event.start == event.end && event.start == s.getStart()) {
						newValue = event.text + s.getActualString();
					}

					if (event.start > s.getStart()) {
						newValue = composeFinalString(event, s, event.text);
					}
				}

				// Handles a single new line. This conditions
				if (event.text.equals("\n")) {
					newValue = composeFinalString(event, s);
					// the editor is not expected to add new lines.
					// Consequently event generated by SWT.CR and SWT.KEYPAD_CR should prompt the
					// text update (done above) but not add new lines.
					event.text = "";
				}
				// when the length of a segment changes, styles with start higher than that has to be updated.
				// see below
				int delta = newValue.length() - s.getActualString().length();

				// Handles the final
				s.setActualString(newValue);
				segmentUtils.drawBox(s);
				segmentUtils.updateStyleRanges(s, delta);
				segmentUtils.applyStyleRanges(getSummaryText());
			});
		};
	}

	private String composeFinalString(VerifyEvent event, Segment<?> s) {
		return composeFinalString(event, s, "");
	}

	private String composeFinalString(VerifyEvent event, Segment<?> s, String insert) {
		String tmp = getSummaryText().getText(s.getStart(), s.getStart() + s.getActualString().length() - 1);
		return tmp.substring(0, event.start  - s.getStart()) + insert + tmp.substring(event.end  - s.getStart(), tmp.length());
	}

	/**
	 * Listen at keyboard entry
	 *
	 * <p>
	 * This is the second action that a user does while the field is editable. There are two possible events
	 *
	 * <ul>
	 * <li>
	 * The user types an alphanumeric key. Number are accepted, letters are not
	 * </li>
	 * <li>
	 * The user types Enter. The edited field is persisted in the StyledText
	 * </li>
	 * <li>
	 * The user types Esc. The edited field is reset to tits original value.
	 * </li>
	 * </ul>
	 * </p>
	 *
	 * @param summaryText
	 * @return a verify Key Listener
	 */
	private VerifyKeyListener getVerifyKeyListener() {
		return event -> {
			segmentUtils
				.segmentAtTextPosition(getSummaryText().getCaretOffset())
				.ifPresent(s -> {
					// Be careful. Order IS important //

					if (handleArrows(event))
						return;

					if (handleNotEditable(s, event))
						return;

					// If the user presses "Enter" the field is saved
					if (handleEnter(s, event))
						return;

					// If the user presses "Esc" the field value is restored
					if (handleEsc(s, event))
						return;

					// Handles Backspace and Delete
					if (handleBackspaceAndDel(s, event))
						return;

					// The user can enter at most one '.'
					if (handleDot(s, event))
						return;

					if (rejectNotDigit(event))
						return;
			});
		};
	}

	private boolean handleArrows(VerifyEvent event) {
        if (event.keyCode == SWT.ARROW_UP || event.keyCode == SWT.ARROW_DOWN
                || event.keyCode == SWT.ARROW_LEFT || event.keyCode == SWT.ARROW_RIGHT) {
                event.doit = true;
                return true;
       	}
		return false;
	}

	private boolean handleNotEditable(Segment<?> segment, VerifyEvent event) {
		if (!segment.getGroup().isEditable()) {
			event.doit = false;
			return true;
		}
		return false;
	}

	private boolean handleEnter(Segment<?> segment, VerifyEvent event) {
		if ((event.character == SWT.CR) || (event.character == SWT.KEYPAD_CR)) {
			if (!persist(segment))
				restore(segment);
			return true;
		}
		return false;
	}

	private boolean handleEsc(Segment<?> segment, VerifyEvent event) {
		if ((event.character == SWT.ESC)) {
			restore(segment);
			return true;
		}
		return false;
	}

	private boolean handleBackspaceAndDel(Segment<?> segment, VerifyEvent event) {
		if ((event.character == SWT.BS || event.character == SWT.DEL)) {
			handleBackspaceAndDelete(segment, event);
			return true;
		}
		return false;
	}

	private boolean handleDot(Segment<?> segment, VerifyEvent event) {
		if (event.character == '.' && segment.getActualString().contains(".")) {
			event.doit = false;
			return true;
		}
		return false;
	}

	private boolean rejectNotDigit(VerifyEvent event) {
		if (event.character == '.')
			return false;
		try {
			Double.parseDouble(String.valueOf(event.character));
		} catch (NumberFormatException e) {
			event.doit = false;
			return true;
		}
		return false;
	}

	private boolean persist(Segment<?> segment) {
		double oldValue = segment.getNumericValue();
		segment.setNumericValue(Double.parseDouble(segment.getActualString()));
		Optional<AcquisitionTemplateType> templateType = getScanningAcquisitionTemporaryHelper()
				.getSelectedAcquisitionTemplateType();
		if (templateType.isPresent()) {
			try {
				SummaryHandler.validate(segmentUtils);
			} catch (GDAClientException e) {
				UIHelper.showError("Range error", e);
				segment.setNumericValue(oldValue);
				return false;
			}
		}
		segment.getGroup().persist();
		getSummaryText().setSelectionRange(segment.getStart(), segment.getActualString().length());
		getSummaryText().insert(segment.getActualString());
		return true;
	}

	private void restore(Segment<?> segment) {
		// saves the actual segment length()
		int oldLength = segment.getActualString().length();
		getSummaryText().setSelectionRange(segment.getStart(), oldLength);
		segment.restore();
		getSummaryText().insert(segment.getActualString());
		segmentUtils.updateStyleRanges(segment, segment.getActualString().length() - oldLength);
		segmentUtils.applyStyleRanges(getSummaryText());
		getSummaryText().setEditable(false);
	}

	private void handleBackspaceAndDelete(Segment<?> segment, VerifyEvent event) {
		if (getSummaryText().getCaretOffset() == segment.getStart()) {
			event.doit = false;
		}
	}

	private ScanningAcquisitionTemporaryHelper getScanningAcquisitionTemporaryHelper() {
		return SpringApplicationContextFacade.getBean(ScanningAcquisitionTemporaryHelper.class);
	}
}
