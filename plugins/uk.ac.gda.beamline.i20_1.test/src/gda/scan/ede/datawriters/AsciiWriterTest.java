/*-
 * Copyright Â© 2018 Diamond Light Source Ltd.
 *
 * This file is part of GDA.
 *
 * GDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 as published by the Free
 * Software Foundation.
 *
 * GDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GDA. If not, see <http://www.gnu.org/licenses/>.
 */

package gda.scan.ede.datawriters;

import static org.junit.Assert.assertEquals;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.dawnsci.nexus.NexusException;
import org.eclipse.january.dataset.DatasetFactory;
import org.eclipse.january.dataset.DoubleDataset;
import org.eclipse.january.dataset.IDataset;
import org.junit.Test;

import gda.scan.EdeTestBase;
import gda.scan.TurboXasNexusTree;
import gda.scan.TurboXasScanTest;

public class AsciiWriterTest extends EdeTestBase {

	/** This is a copy of the Nexus file generated by {@link TurboXasScanTest#testAsciiWriterProcessesNexusFile()} */
	private String nexusFilename = "testfiles/gda/scan/TurboXasScan/1_testAsciiWriterProcessesNexusFile.nxs";

	/** This is a copy of the Nexus file generated by {@link TurboXasScanTest#testTurboXasScanMultipleSpectra()} */
	private String nexusFilenameTwoWay = "testfiles/gda/scan/TurboXasScan/1_testTurboXasScanMultipleSpectra.nxs";

	private int numSpectra;
	private int numEnergiesInNexus;
	private int numBufferedScalerFields =TurboXasScanTest.BUFFERED_SCALER_FIELDS.length;

	boolean isTwoWayScan = false;
	boolean ignoreNan = false;

	private String setdimensions(String nexusPath) throws NexusException {
		String absolutePath = Paths.get(nexusPath).toAbsolutePath().toString();
		IDataset data = getDataset(absolutePath, TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasScanTest.BUFFERED_SCALER_FIELDS[0]);
		int[] dataShape = data.getShape();
		numBufferedScalerFields = TurboXasScanTest.BUFFERED_SCALER_FIELDS.length;
		numSpectra = dataShape[0];
		numEnergiesInNexus = dataShape[1];
		return absolutePath;
	}

	/**
	 * @return AsciiDataWriter object, setup to read Nexus file and write to current test directory.
	 * @throws NexusException
	 */
	private AsciiWriter getAsciiWriter(String nexusFilename) throws NexusException {
		AsciiWriter asciiWriter = new AsciiWriter();
		Path asciiDir = Paths.get(testDir).toAbsolutePath();
		// make parent directories if needed
		if (!asciiDir.toFile().exists()) {
			asciiDir.toFile().mkdirs();
		}
		Path asciiFilepath = asciiDir.resolve("1.txt");
		asciiWriter.setAsciiFilename(asciiFilepath.toString());
		asciiWriter.setDetectorNames(new String[] {TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasScanTest.BUFFERED_XSPRESS3_NAME});
		asciiWriter.setIgnoreNaNs(false);

		String absolutePath = setdimensions(nexusFilename);
		asciiWriter.setNexusFilename(absolutePath);

		return asciiWriter;
	}

	@Test
	public void testAllFieldsProcessed() throws Exception {
		setup(AsciiWriterTest.class, "testAllFieldsProcessed");

		AsciiWriter asciiWriter = getAsciiWriter(nexusFilename);
		asciiWriter.writeAsciiFile();
		checkAsciiFile(asciiWriter.getAsciiFilename(), numBufferedScalerFields+TurboXasScanTest.BUFFERED_XSPRESS3_FIELDS.length);
		checkDataInColumns(asciiWriter.getNexusFilename(), asciiWriter.getAsciiFilename());
	}

	@Test
	public void testAllBufferedScalerFieldsProcessed() throws Exception {
		setup(AsciiWriterTest.class, "testAllBufferedScalerFieldsProcessed");

		AsciiWriter asciiWriter = getAsciiWriter(nexusFilename);
		asciiWriter.setDetectorNames(new String[] {TurboXasScanTest.BUFFERED_SCALER_NAME});
		asciiWriter.writeAsciiFile();

		checkAsciiFile(asciiWriter.getAsciiFilename(), numBufferedScalerFields);
		checkDataInColumns(asciiWriter.getNexusFilename(), asciiWriter.getAsciiFilename());
	}

	@Test
	public void testSelectedFieldsProcessed() throws Exception {
		setup(AsciiWriterTest.class, "testSelectedFieldsProcessed");

		AsciiWriter asciiWriter = getAsciiWriter(nexusFilename);
		asciiWriter.setDetectorNames(new String[] {TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasScanTest.BUFFERED_XSPRESS3_NAME});
		String[] dataToRead = new String[] {"/entry1/"+TurboXasScanTest.BUFFERED_SCALER_NAME+"/It",
				"/entry1/"+TurboXasScanTest.BUFFERED_XSPRESS3_NAME+"/"+TurboXasScanTest.BUFFERED_XSPRESS3_FIELDS[1],
				"/entry1/"+TurboXasScanTest.BUFFERED_XSPRESS3_NAME+"/"+TurboXasScanTest.BUFFERED_XSPRESS3_FIELDS[2]};
		asciiWriter.setDataToRead(dataToRead);
		asciiWriter.writeAsciiFile();

		checkAsciiFile(asciiWriter.getAsciiFilename(), dataToRead.length);
		checkDataInColumns(asciiWriter.getNexusFilename(), asciiWriter.getAsciiFilename());
	}

	@Test
	public void testNaNs() throws Exception {
		setup(AsciiWriterTest.class, "testNaNs");

		AsciiWriter asciiWriter = getAsciiWriter(nexusFilename);
		asciiWriter.setNexusFilename(nexusFilename);
		asciiWriter.setDetectorNames(new String[] {TurboXasScanTest.BUFFERED_SCALER_NAME});
		asciiWriter.setIgnoreNaNs(true);
		asciiWriter.writeAsciiFile();

		ignoreNan = true;
		isTwoWayScan = false;
		checkAsciiFile(asciiWriter.getAsciiFilename(), numBufferedScalerFields);
		checkDataInColumns(asciiWriter.getNexusFilename(), asciiWriter.getAsciiFilename());
	}

	@Test
	public void testNaNsTwoWay() throws Exception {
		setup(AsciiWriterTest.class, "testNaNsTwoWay");

		AsciiWriter asciiWriter = getAsciiWriter(nexusFilenameTwoWay);
		asciiWriter.setDetectorNames(new String[] {TurboXasScanTest.BUFFERED_SCALER_NAME});
		asciiWriter.setIgnoreNaNs(true);
		asciiWriter.writeAsciiFile();

		ignoreNan = true;
		isTwoWayScan = true;
		checkAsciiFile(asciiWriter.getAsciiFilename(), numBufferedScalerFields);
		checkDataInColumns(asciiWriter.getNexusFilename(), asciiWriter.getAsciiFilename());
	}
	/**
	 * Check that the number of rows and columns in Ascii file are correct, and that there are the same number of columns in each row.
	 * @param filename
	 * @param numColumnsPerSpectrum
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private void checkAsciiFile(String filename, int numColumnsPerSpectrum) throws FileNotFoundException, IOException {
		List<String[]> dataFromFile = getDataFromAsciiFile(filename);

		// Number of rows should match number of energies
		assertEquals(dataFromFile.size(), getNumEnergiesInAscii());

		// Number of columns in each row should match number of fields
		int numAxisColumns = 3;
		for(int i=0; i<dataFromFile.size(); i++) {
			assertEquals("Incorrect number of columns in row "+i+" of table.", dataFromFile.get(i).length, numAxisColumns + numColumnsPerSpectrum * numSpectra);
		}
	}

	/**
	 * Check numerical values of the data in all the columns: load datasets from Nexus file
	 * and comparing the numbers with those from Ascii file.
	 * @param filename
	 * @throws IOException
	 * @throws NexusException
	 */
	private void checkDataInColumns(String nexusAbsolutePath, String filename) throws IOException, NexusException {
		List<String[]> dataFromFile = getDataFromAsciiFile(filename);
		String[] columnNames = getColumnNames(filename);
		Map<String, IDataset> datasetMap = getColumnDataMap(dataFromFile, columnNames);

		// Test axis data
		IDataset frameIndex = getNexusDataset(nexusAbsolutePath, TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasNexusTree.FRAME_INDEX);
		assertDatasetsMatch(frameIndex, datasetMap.get("#Index"), 1e-5);

		IDataset position = getNexusDataset(nexusAbsolutePath, TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasNexusTree.POSITION_COLUMN_NAME);
		assertDatasetsMatch(position, datasetMap.get(TurboXasNexusTree.POSITION_COLUMN_NAME), 1e-5);

		IDataset energy = getNexusDataset(nexusAbsolutePath, TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasNexusTree.ENERGY_COLUMN_NAME);
		assertDatasetsMatch(energy, datasetMap.get(TurboXasNexusTree.ENERGY_COLUMN_NAME), 1e-5);

		checkDetectorData(nexusAbsolutePath, datasetMap, TurboXasScanTest.BUFFERED_SCALER_NAME, TurboXasScanTest.BUFFERED_SCALER_FIELDS);
		checkDetectorData(nexusAbsolutePath, datasetMap, TurboXasScanTest.BUFFERED_XSPRESS3_NAME, TurboXasScanTest.BUFFERED_XSPRESS3_FIELDS);
	}

	private int getNumEnergiesInAscii() {
		int numSpectraPoints = numEnergiesInNexus;
		if (ignoreNan) {
			numSpectraPoints--;
			if (isTwoWayScan) {
				numSpectraPoints--;
			}
		}
		return numSpectraPoints;
	}

	/**
	 * Read a dataset from Nexus file, taking a slice so that NaN values are not included at start/end of each spectrum.
	 * @param nexusFilename
	 * @param groupName
	 * @param dataName
	 * @return IDataset
	 * @throws NexusException
	 */
	public IDataset getNexusDataset(String nexusFilename, String groupName, String dataName) throws NexusException {
		IDataset dataset = getDataset(nexusFilename, groupName, dataName);
		int stopSpectrumIndex = numEnergiesInNexus;
		int startSpectrumIndex = 0;

		// Adjust start, stop indices so that NaNs are not included at start/end of each spectrum
		if (ignoreNan) {
			stopSpectrumIndex--;
			if (isTwoWayScan) {
				startSpectrumIndex=1;
			}
		}

		if (dataset.getShape().length == 1) {
			return dataset.getSlice(new int[] {startSpectrumIndex}, new int[] {stopSpectrumIndex}, null);
		} else {
			return dataset.getSlice(new int[] {0, startSpectrumIndex}, new int[] {numSpectra, stopSpectrumIndex}, null);
		}
	}

	/**
	 *
	 * @param filename
	 * @return Names of data columns from ascii file; columns are on line that starts with "#Index".
	 * @throws IOException
	 */
	private String[] getColumnNames(String filename) throws IOException {
		List<String> lines = Files.readAllLines(Paths.get(filename), Charset.defaultCharset());
		String[] columnNames = {};
		for(String line : lines) {
			if (line.trim().startsWith("#Index")) {
				columnNames = line.trim().split("\\s+");
				break;
			}
		}
		return columnNames;
	}

	/**
	 * Convert string values in each column to numbers, make dataset from the values.
	 * @param dataFromFile
	 * @param columnNames
	 * @return  Map with key = column name, value = dataset of values in the column.
	 */
	private Map<String, IDataset> getColumnDataMap(List<String[]> dataFromFile, String[] columnNames) {
		Map<String, IDataset> datasetMap = new LinkedHashMap<>();

		int numEnergies = dataFromFile.size();
		for(int col = 0; col < columnNames.length; col++) {
			IDataset dataset = DatasetFactory.zeros(DoubleDataset.class, new int[]{numEnergies});
			for(int row = 0; row < numEnergies; row++) {
				dataset.set( Double.parseDouble(dataFromFile.get(row)[col]), row);
			}
			dataset.setName(columnNames[col]);
			datasetMap.put(columnNames[col], dataset);
		}
		return datasetMap;
	}

	/**
	 * Load data from Nexus file in /entry1/'groupName'/fieldName and compare with same data loaded from Ascii file
	 * @param datasetMap data from ascii file : key = column name, value = data in column
	 * @param groupName - group name in Nexus containing dataset(s) to be read
	 * @param nexusDatasetNames - dataset in group to be read compared
	 * @throws NexusException
	 */
	private void checkDetectorData(String nexusAbsolutePath, Map<String, IDataset> datasetMap, String groupName, String[] nexusDatasetNames) throws NexusException {
		String[] columnNames = datasetMap.keySet().toArray(new String[] {});
		for(String nexusDatasetName : nexusDatasetNames ) {
			// Get list of columns in ascii file corresponding to this dataset - there should be one column
			// per spectrum (in collection order, i.e. same order of appearence in the file)
			List<String> columns = getStringsContainingName(columnNames, "/"+nexusDatasetName+"_(");
			if (columns.isEmpty()) {
				continue;
			}
			// Get dataset from Nexus file
			IDataset dataset = getNexusDataset(nexusAbsolutePath, groupName, nexusDatasetName);

			// Compare the dataset for each spectrum
			int numEnergies = dataset.getShape()[1];
			for (int specNum = 0; specNum < columns.size(); specNum++) {
				String columnName = columns.get(specNum);
				System.out.println(String.format("Checking dataset %s : ascii column name %d (%s)", dataset.getName(), specNum, columnName));
				IDataset dataForSpectrum = dataset.getSlice(new int[] { specNum, 0 }, new int[] { specNum + 1, numEnergies }, null).squeeze();
				assertDatasetsMatch(dataForSpectrum, datasetMap.get(columnName), 1e-4);
			}
		}
	}

	/**
	 *
	 * @param stringsToSearch
	 * @param nameToMatch
	 * @return List of strings from 'stringsToSearch' that contain string 'nameToMatch'
	 */
	private List<String> getStringsContainingName(String[] stringsToSearch, String nameToMatch) {
		List<String> matchingNames = new ArrayList<>();
		for(String name : stringsToSearch) {
			if (name.contains(nameToMatch)) {
				matchingNames.add(name);
			}
		}
		return matchingNames;
	}
}
